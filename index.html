<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BRU GTA: Kigali Forest & Wildlife</title>
<style>
:root{
  --bg:#0a0d12;
  --panel:#0e141b;
  --glass:rgba(12,16,22,.85);
  --accent:#69a8ff;
  --ok:#57d68d;
  --warn:#ffb84d;
  --bad:#ff6b6b;
  --forest:#1a3a1a;
  --water:#1e4d5f;
}

html,body{
  margin:0;
  height:100%;
  background:var(--bg);
  color:#e6edf3;
  font-family:'Segoe UI',Arial,sans-serif;
  overflow:hidden;
}

canvas{
  display:block;
  width:100vw;
  height:100vh;
}

#hud{
  position:fixed;
  top:12px;
  right:12px;
  display:grid;
  gap:10px;
  min-width:260px;
  pointer-events:none;
  z-index:1000;
}

.card{
  pointer-events:auto;
  background:var(--glass);
  backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.15);
  padding:14px 16px;
  border-radius:16px;
  box-shadow:0 16px 40px rgba(0,0,0,.5);
}

.row{
  display:flex;
  justify-content:space-between;
  gap:14px;
  align-items:center;
  margin:4px 0;
}

.bar{
  height:14px;
  border-radius:12px;
  background:#1b2430;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.08);
}

.bar>div{
  height:100%;
  background:linear-gradient(90deg,#46e,#4ee);
  width:100%;
  transition:width 0.3s ease;
}

.bar.ok>div{background:linear-gradient(90deg,#35d6a0,#5eefc3)}
.bar.warn>div{background:linear-gradient(90deg,#ffb84d,#ffe27a)}
.bar.bad>div{background:linear-gradient(90deg,#ff6b6b,#ff9a9a)}

#timerDisplay{
  font-size:20px;
  font-weight:bold;
  color:#ff6b6b;
  text-shadow:0 0 10px rgba(255,107,107,.6);
}

#timeIndicator{
  display:flex;
  align-items:center;
  gap:10px;
  font-size:15px;
}

.time-icon{
  width:18px;
  height:18px;
  border-radius:50%;
  display:inline-block;
}

.day-icon{
  background:linear-gradient(135deg,#ffd700,#ff8c00);
  box-shadow:0 0 10px rgba(255,215,0,.5);
}

.night-icon{
  background:linear-gradient(135deg,#4169e1,#191970);
  box-shadow:0 0 10px rgba(65,105,225,.5);
}

#crosshair{
  position:fixed;
  inset:0;
  pointer-events:none;
  display:grid;
  place-items:center;
  z-index:999;
}

#crosshair div{
  width:24px;
  height:24px;
  border:3px solid rgba(255,255,255,.95);
  border-radius:50%;
  box-shadow:0 0 14px rgba(255,255,255,.5);
}

#minimap{
  position:fixed;
  right:12px;
  bottom:12px;
  width:200px;
  height:200px;
  border:3px solid #fff;
  border-radius:14px;
  background:#000;
  box-shadow:0 16px 40px rgba(0,0,0,.6);
  z-index:1000;
}

#controls{
  position:fixed;
  left:12px;
  bottom:12px;
  display:none;
  max-width:450px;
  z-index:1000;
}

#gameover{
  display:none;
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.95);
  color:#fff;
  align-items:center;
  justify-content:center;
  flex-direction:column;
  gap:24px;
  font-size:36px;
  pointer-events:auto;
  z-index:2000;
}

#gameover button{
  font-size:22px;
  padding:14px 28px;
  border-radius:14px;
  border:2px solid #556;
  cursor:pointer;
  background:#1a2230;
  color:#e6edf3;
  transition:all 0.3s ease;
}

#gameover button:hover{
  background:#2a3240;
  border-color:#69a8ff;
  transform:scale(1.05);
}

#killFeed{
  position:fixed;
  top:12px;
  left:12px;
  max-width:350px;
  z-index:1000;
  pointer-events:none;
}

.kill-msg{
  background:var(--glass);
  backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.1);
  padding:10px 14px;
  border-radius:10px;
  margin-bottom:6px;
  font-size:14px;
  opacity:0;
  animation:fadeInOut 3.5s ease-out forwards;
}

@keyframes fadeInOut{
  0%{opacity:0;transform:translateX(-25px)}
  20%{opacity:1;transform:translateX(0)}
  80%{opacity:1;transform:translateX(0)}
  100%{opacity:0;transform:translateX(-25px)}
}

kbd{
  background:#333;
  padding:3px 7px;
  border-radius:5px;
  font-size:13px;
  border:1px solid #555;
}

#audioToggle{
  position:fixed;
  bottom:12px;
  left:50%;
  transform:translateX(-50%);
  background:var(--glass);
  backdrop-filter:blur(12px);
  border:1px solid rgba(255,255,255,.15);
  padding:10px 16px;
  border-radius:10px;
  cursor:pointer;
  font-size:13px;
  z-index:1000;
}

#locationInfo{
  position:fixed;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  background:var(--glass);
  backdrop-filter:blur(12px);
  border:2px solid rgba(255,255,255,.2);
  padding:20px 30px;
  border-radius:16px;
  font-size:28px;
  font-weight:bold;
  color:#ffd700;
  text-shadow:0 0 12px rgba(255,215,0,.6);
  z-index:1500;
  display:none;
  animation:locationPulse 2s ease-out forwards;
}

@keyframes locationPulse{
  0%{opacity:0;transform:translate(-50%,-50%) scale(0.8)}
  20%{opacity:1;transform:translate(-50%,-50%) scale(1.1)}
  80%{opacity:1;transform:translate(-50%,-50%) scale(1)}
  100%{opacity:0;transform:translate(-50%,-50%) scale(0.9)}
}

.wildlife-warning{
  background:linear-gradient(135deg,#ff4444,#cc0000)!important;
  color:#fff!important;
  font-weight:bold;
  border:2px solid #ff6666!important;
}
</style>
</head>
<body>
<footer><creator>INEZA AIME BRUNO - Kigali Forest & Wildlife Edition</creator></footer>

<canvas id="c"></canvas>

<div id="hud">
  <div class="card" id="stats">
    <div class="row">
      <div id="timeIndicator">
        <span class="time-icon day-icon" id="timeIcon"></span>
        <span id="dayNightTxt">Day</span>
      </div>
      <div id="timerDisplay">05:00</div>
    </div>
    <div class="row"><div>Location</div><div id="locationTxt">Kigali City</div></div>
    <div class="row"><div>Mode</div><div id="modeTxt">On Foot</div></div>
    <div class="row"><div>Health</div><div id="hpTxt">100%</div></div>
    <div class="bar ok"><div id="hpbar" style="width:100%"></div></div>
    <div class="row"><div>Kills</div><div id="killsTxt">0</div></div>
  </div>
  <div class="card" id="weapon">
    <div>Weapon: <b id="wepName">Rifle</b></div>
    <div><small>Press <kbd>H</kbd> to switch</small></div>
  </div>
</div>

<div id="killFeed"></div>
<canvas id="minimap" width="200" height="200"></canvas>

<div id="controls" class="card">
  <div style="font-weight:700;margin-bottom:10px;font-size:16px">Controls</div>
  <div style="font-size:14px;line-height:1.6">
    <b>Move:</b> <kbd>WASD</kbd>, <kbd>Mouse</kbd> look, <kbd>Space</kbd> jump<br>
    <b>Vehicles:</b> <kbd>E</kbd> enter/exit, <kbd>Arrows</kbd> drive<br>
    <b>Combat:</b> <kbd>Click</kbd> fire, <kbd>H</kbd> switch weapon<br>
    <b>Buildings:</b> <kbd>E</kbd> enter (night only)<br>
    <b>Other:</b> <kbd>N</kbd> day/night, <kbd>5</kbd> help, <kbd>M</kbd> audio<br>
    <b>Landmarks:</b> Explore Kigali Convention Center, Amahoro Stadium, Pelé Stadium<br>
    <b>Wildlife:</b> Avoid predators in Nyungwe Forest (they hunt vehicles!)<br>
    <b style="color:#ffd700">Created by INEZA AIME BRUNO</b>
  </div>
</div>

<div id="crosshair"><div></div></div>

<div id="gameover">
  <div>GAME OVER</div>
  <div style="font-size:20px;margin:12px 0">Time Survived: <span id="finalTime">00:00</span></div>
  <div style="font-size:20px;margin:12px 0">Kills: <span id="finalKills">0</span></div>
  <button id="btnNew">New Game</button>
</div>

<div id="audioToggle">Audio: ON</div>
<div id="locationInfo"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
(() => {
  // ========== CORE SETUP ==========
  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x87ceeb, 100, 400);

  const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 10, 20);

  // ========== LIGHTING SYSTEM ==========
  const sun = new THREE.DirectionalLight(0xffffff, 1.3);
  sun.position.set(-100, 120, 100);
  sun.castShadow = true;
  sun.shadow.mapSize.width = 2048;
  sun.shadow.mapSize.height = 2048;
  sun.shadow.camera.near = 1;
  sun.shadow.camera.far = 300;
  sun.shadow.camera.left = -150;
  sun.shadow.camera.right = 150;
  sun.shadow.camera.top = 150;
  sun.shadow.camera.bottom = -150;
  
  const moon = new THREE.DirectionalLight(0x9bb7ff, 0.0);
  moon.position.set(100, 120, -100);
  moon.castShadow = true;
  moon.shadow.mapSize.width = 1024;
  moon.shadow.mapSize.height = 1024;
  
  const ambient = new THREE.AmbientLight(0xa0b5c8, 0.45);
  scene.add(sun, moon, ambient);

  window.addEventListener('resize', ()=>{
    camera.aspect = innerWidth/innerHeight; 
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // ========== GAME STATE ==========
  let gameStartTime = Date.now();
  let totalKills = 0;
  let audioEnabled = true;
  let isNight = false;
  let dayNightTimer = 0;
  const DAY_DURATION = 210;
  const NIGHT_DURATION = 150;

  // ========== PLAYER STATE ==========
  let playerHP = 100;
  let playerTimer = 300;
  let onCar = false, currentCar = null;
  let inHouse = false, currentHouseIndex = -1;
  let weapon = 'rifle';
  let rocketCooldown = 0;
  let currentLocation = 'Kigali City';
  let lastVehicleStopPosition = null;

  // ========== HELPER FUNCTIONS ==========
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const rand = (a,b)=>Math.random()*(b-a)+a;
  const dist2 = (a,b)=>{const dx=a.x-b.x,dz=a.z-b.z;return dx*dx+dz*dz;}
  const dist3 = (a,b)=>Math.sqrt((a.x-b.x)**2+(a.y-b.y)**2+(a.z-b.z)**2);

  // ========== AUDIO SYSTEM ==========
  const audioContext = new (window.AudioContext || window.webkitAudioContext)();
  
  function createTone(freq, duration, type='sine', volume=0.08) {
    if (!audioEnabled) return;
    try {
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.value = freq;
      oscillator.type = type;
      gainNode.gain.value = volume;
      oscillator.start();
      oscillator.stop(audioContext.currentTime + duration);
    } catch(e) {}
  }

  function playRifleSound() { createTone(420, 0.12, 'square', 0.04); }
  function playRocketSound() { createTone(180, 0.35, 'sawtooth', 0.07); }
  function playExplosionSound() { createTone(70, 0.6, 'sawtooth', 0.1); }
  function playAnimalRoar() { createTone(150, 0.8, 'sawtooth', 0.15); }

  // ========== TERRAIN ==========
  const WORLD_SIZE = 800;
  const FOREST_START_X = 200;
  const FOREST_END_X = 600;
  const FOREST_START_Z = -300;
  const FOREST_END_Z = 300;

  const ground = new THREE.Mesh(
    new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 20, 20), 
    new THREE.MeshLambertMaterial({color:0x3a4a3a})
  );
  ground.rotation.x = -Math.PI/2; 
  ground.receiveShadow = true; 
  scene.add(ground);

  // ========== ROADS ==========
  const roads = new THREE.Group();
  const roadMat = new THREE.MeshLambertMaterial({color:0x2a2f35});
  
  for(let i=-10; i<=10; i++){
    const r1 = new THREE.Mesh(new THREE.BoxGeometry(WORLD_SIZE, 0.1, 5), roadMat); 
    r1.position.set(0, 0.01, i*35); 
    r1.receiveShadow = true;
    roads.add(r1);
    
    if(i < 6){
      const r2 = new THREE.Mesh(new THREE.BoxGeometry(5, 0.1, 400), roadMat); 
      r2.position.set(i*35, 0.01, 0); 
      r2.receiveShadow = true;
      roads.add(r2);
    }
  }
  scene.add(roads);

  // ========== NYUNGWE FOREST ==========
  const forest = new THREE.Group();
  const trees = [];
  
  function makeMinecraftTree(x, z){
    const tree = new THREE.Group();
    
    // Dark wood trunk
    const trunk = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 8, 1.2),
      new THREE.MeshLambertMaterial({color:0x3a2818})
    );
    trunk.position.y = 4;
    trunk.castShadow = true;
    trunk.receiveShadow = true;
    
    // Blocky leaves (Minecraft style)
    const leafMat = new THREE.MeshLambertMaterial({color:0x1a5a1a});
    
    for(let layer = 0; layer < 3; layer++){
      const size = 5 - layer;
      const leaves = new THREE.Mesh(
        new THREE.BoxGeometry(size, 2, size),
        leafMat
      );
      leaves.position.y = 7 + layer * 2;
      leaves.castShadow = true;
      leaves.receiveShadow = true;
      tree.add(leaves);
    }
    
    tree.add(trunk);
    tree.position.set(x, 0, z);
    tree.userData = {type:'tree', hw:2.5, hh:10, hd:2.5};
    
    return tree;
  }

  // Create dense Nyungwe Forest
  for(let i = 0; i < 200; i++){
    const x = rand(FOREST_START_X, FOREST_END_X);
    const z = rand(FOREST_START_Z, FOREST_END_Z);
    
    const tree = makeMinecraftTree(x, z);
    forest.add(tree);
    trees.push(tree);
  }
  scene.add(forest);

  // ========== WILD LAKES ==========
  const lakes = new THREE.Group();
  
  function makeLake(x, z, radius){
    const lake = new THREE.Mesh(
      new THREE.CylinderGeometry(radius, radius, 0.5, 32),
      new THREE.MeshLambertMaterial({
        color:0x1e4d5f,
        transparent:true,
        opacity:0.7
      })
    );
    lake.position.set(x, -0.2, z);
    lake.rotation.x = 0;
    lake.receiveShadow = true;
    lake.userData = {type:'lake', radius};
    return lake;
  }

  // Create 3 lakes in forest
  lakes.add(makeLake(350, -150, 30));
  lakes.add(makeLake(450, 50, 25));
  lakes.add(makeLake(520, -200, 35));
  scene.add(lakes);

  // ========== ENHANCED HUMANOID MODELS ==========
  function makeRealisticHumanoid(colors, isPlayer=false){
    const g = new THREE.Group();
    
    // Proportional body parts
    const torsoW = 1.2, torsoH = 2.0, torsoD = 0.8;
    const torso = new THREE.Mesh(
      new THREE.BoxGeometry(torsoW, torsoH, torsoD), 
      new THREE.MeshLambertMaterial({color:colors.shirt})
    );
    torso.position.y = 2.5;
    torso.castShadow = true;
    g.add(torso);
    
    // Head
    const headSize = 0.7;
    const head = new THREE.Mesh(
      new THREE.BoxGeometry(headSize, headSize, headSize), 
      new THREE.MeshLambertMaterial({color:0xffd7b0})
    );
    head.position.y = 3.8;
    head.castShadow = true;
    g.add(head);
    
    // Eyes
    const eyeMat = new THREE.MeshBasicMaterial({color:0x000000});
    const eyeA = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.06), eyeMat);
    eyeA.position.set(0.15, 3.85, headSize/2 + 0.01);
    const eyeB = eyeA.clone();
    eyeB.position.x = -0.15;
    g.add(eyeA, eyeB);
    
    // Arms (separate for animation)
    const armW = 0.35, armH = 1.8, armD = 0.35;
    const armMat = new THREE.MeshLambertMaterial({color:colors.sleeve});
    
    const armL = new THREE.Mesh(new THREE.BoxGeometry(armW, armH, armD), armMat);
    armL.position.set(-torsoW/2 - armW/2, 2.5, 0);
    armL.castShadow = true;
    g.add(armL);
    
    const armR = armL.clone();
    armR.position.x = torsoW/2 + armW/2;
    armR.castShadow = true;
    g.add(armR);
    
    // Legs (separate for animation)
    const legW = 0.45, legH = 2.2, legD = 0.45;
    const legMat = new THREE.MeshLambertMaterial({color:colors.pants});
    
    const legL = new THREE.Mesh(new THREE.BoxGeometry(legW, legH, legD), legMat);
    legL.position.set(-torsoW/4, 0.6, 0);
    legL.castShadow = true;
    g.add(legL);
    
    const legR = legL.clone();
    legR.position.x = torsoW/4;
    legR.castShadow = true;
    g.add(legR);
    
    // Weapon anchor
    const weaponAnchor = new THREE.Group();
    weaponAnchor.position.set(torsoW/2 + armW + 0.2, 2.5, 0.3);
    g.add(weaponAnchor);
    
    // Hair
    const hair = new THREE.Mesh(
      new THREE.BoxGeometry(headSize + 0.1, 0.3, headSize + 0.1),
      new THREE.MeshLambertMaterial({color:colors.hair})
    );
    hair.position.y = 4.2;
    hair.castShadow = true;
    g.add(hair);
    
    g.userData = {
      torso, head, armL, armR, legL, legR, weaponAnchor,
      walkT:0, alive:true, type:'humanoid',
      hw:0.6, hh:2.0, hd:0.5
    };
    
    return g;
  }

  // ========== PLAYER ==========
  const player = makeRealisticHumanoid({
    shirt:0x3a4a5a,
    pants:0x2a3a4a,
    sleeve:0x3a4a5a,
    hair:0x1a1a1a
  }, true);
  player.position.set(0, 0, 10);
  scene.add(player);

  // ========== WEAPONS ==========
  function makeAssaultRifle(){
    const gun = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1.2, 0.18, 0.25), 
      new THREE.MeshLambertMaterial({color:0x1a1f24})
    );
    body.position.set(0.3, 0, 0);
    body.castShadow = true;
    
    const barrel = new THREE.Mesh(
      new THREE.BoxGeometry(0.7, 0.12, 0.12), 
      new THREE.MeshLambertMaterial({color:0x2a2f34})
    );
    barrel.position.set(0.8, 0, 0);
    barrel.castShadow = true;
    
    gun.add(body, barrel);
    gun.rotation.z = -Math.PI/8;
    return gun;
  }
  
  function makeRocketLauncher(){
    const rl = new THREE.Group();
    const tube = new THREE.Mesh(
      new THREE.CylinderGeometry(0.14, 0.14, 1.4, 10), 
      new THREE.MeshLambertMaterial({color:0x2a3d2a})
    );
    tube.rotation.z = Math.PI/2;
    tube.position.x = 0.6;
    tube.castShadow = true;
    rl.add(tube);
    rl.rotation.z = -Math.PI/12;
    return rl;
  }
  
  const assaultRifleModel = makeAssaultRifle();
  const rocketLauncherModel = makeRocketLauncher();
  player.userData.weaponAnchor.add(assaultRifleModel);
  
  function setWeapon(name){
    weapon = name;
    document.getElementById('wepName').textContent = (weapon==='rifle')?'Rifle':'Launcher';
    player.userData.weaponAnchor.clear();
    player.userData.weaponAnchor.add(weapon==='rifle'?assaultRifleModel:rocketLauncherModel);
  }

  // ========== KIGALI LANDMARKS ==========
  const landmarks = new THREE.Group();
  scene.add(landmarks);

  // Kigali Convention Center (Iconic Dome with neon rings)
  function makeKCC(){
    const kcc = new THREE.Group();
    
    // Main dome structure
    const dome = new THREE.Mesh(
      new THREE.SphereGeometry(25, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
      new THREE.MeshLambertMaterial({color:0x4a5a6a})
    );
    dome.position.y = 15;
    dome.castShadow = true;
    dome.receiveShadow = true;
    kcc.add(dome);
    
    // Neon rings
    const ringColors = [0x00ff00, 0xffff00, 0x0088ff];
    for(let i = 0; i < 3; i++){
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(26 + i * 3, 0.5, 16, 32),
        new THREE.MeshBasicMaterial({
          color:ringColors[i],
          emissive:ringColors[i],
          emissiveIntensity:0.8
        })
      );
      ring.position.y = 8 + i * 5;
      ring.rotation.x = Math.PI / 2;
      kcc.add(ring);
    }
    
    // Base platform
    const base = new THREE.Mesh(
      new THREE.CylinderGeometry(30, 35, 8, 32),
      new THREE.MeshLambertMaterial({color:0x3a4a5a})
    );
    base.position.y = 4;
    base.castShadow = true;
    base.receiveShadow = true;
    kcc.add(base);
    
    kcc.position.set(-100, 0, -100);
    kcc.userData = {type:'landmark', name:'Kigali Convention Center', hw:35, hh:30, hd:35};
    return kcc;
  }

  // Amahoro Stadium
  function makeAmahoroStadium(){
    const stadium = new THREE.Group();
    
    // Outer ring
    const outer = new THREE.Mesh(
      new THREE.CylinderGeometry(45, 45, 20, 32, 1, true),
      new THREE.MeshLambertMaterial({color:0x5a6a7a, side:THREE.DoubleSide})
    );
    outer.position.y = 10;
    outer.castShadow = true;
    outer.receiveShadow = true;
    stadium.add(outer);
    
    // Inner field
    const field = new THREE.Mesh(
      new THREE.CylinderGeometry(38, 38, 0.5, 32),
      new THREE.MeshLambertMaterial({color:0x2a6a2a})
    );
    field.position.y = 0.2;
    field.receiveShadow = true;
    stadium.add(field);
    
    // Roof structure
    const roof = new THREE.Mesh(
      new THREE.CylinderGeometry(48, 42, 3, 32, 1, true),
      new THREE.MeshLambertMaterial({color:0x6a7a8a, side:THREE.DoubleSide})
    );
    roof.position.y = 22;
    roof.castShadow = true;
    stadium.add(roof);
    
    stadium.position.set(100, 0, -150);
    stadium.userData = {type:'landmark', name:'Amahoro Stadium', hw:48, hh:25, hd:48};
    return stadium;
  }

  // Pelé Stadium
  function makePeleStadium(){
    const stadium = new THREE.Group();
    
    // Main structure
    const main = new THREE.Mesh(
      new THREE.BoxGeometry(60, 18, 40),
      new THREE.MeshLambertMaterial({color:0x4a5a6a})
    );
    main.position.y = 9;
    main.castShadow = true;
    main.receiveShadow = true;
    stadium.add(main);
    
    // Field
    const field = new THREE.Mesh(
      new THREE.BoxGeometry(50, 0.5, 30),
      new THREE.MeshLambertMaterial({color:0x2a7a2a})
    );
    field.position.y = 0.2;
    field.receiveShadow = true;
    stadium.add(field);
    
    // Goals
    for(let side of [-15, 15]){
      const goal = new THREE.Mesh(
        new THREE.BoxGeometry(8, 3, 0.3),
        new THREE.MeshLambertMaterial({color:0xffffff})
      );
      goal.position.set(side, 1.5, 0);
      goal.castShadow = true;
      stadium.add(goal);
    }
    
    stadium.position.set(-50, 0, 120);
    stadium.userData = {type:'landmark', name:'Pelé Stadium', hw:30, hh:20, hd:20};
    return stadium;
  }

  landmarks.add(makeKCC());
  landmarks.add(makeAmahoroStadium());
  landmarks.add(makePeleStadium());

  // ========== BUILDINGS & HOUSES ==========
  const city = new THREE.Group();
  scene.add(city);
  const houses = [];
  const allBuildings = [];

  function makeBuilding(x, z, isHouse=false){
    const w = rand(10, 18), d = rand(10, 18), h = rand(12, 30);
    const col = new THREE.Color().setHSL(rand(0,1), 0.35, rand(0.35, 0.65));
    
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(w, h, d),
      new THREE.MeshLambertMaterial({color:col})
    );
    body.position.set(x, h/2, z);
    body.castShadow = true;
    body.receiveShadow = true;
    body.userData = {hw:w/2, hh:h/2, hd:d/2, type:'building', hp:800, maxHp:800};
    city.add(body);
    allBuildings.push(body);

    // Door (solid, always visible)
    const door = new THREE.Mesh(
      new THREE.BoxGeometry(2.5, 4, 0.5),
      new THREE.MeshLambertMaterial({color:0x4a3728})
    );
    door.position.set(x, 2, z + d/2 + 0.26);
    door.castShadow = true;
    city.add(door);

    // Windows
    const windowMat = new THREE.MeshLambertMaterial({color:0x87ceeb, emissive:0x1a3350});
    for(let i = 1; i < h/3; i++){
      for(let j = -Math.floor(w/3); j <= Math.floor(w/3); j++){
        if(Math.abs(j) > Math.floor(w/3) - 1) continue;
        const win = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.2), windowMat);
        win.position.set(x + j * 2.5, i * 3, z + d/2 + 0.11);
        city.add(win);
      }
    }

    if(!isHouse) return;

    // House interior
    const interior = new THREE.Group();
    const roomW = 12, roomD = 12, roomH = 4;
    
    const floor = new THREE.Mesh(
      new THREE.BoxGeometry(roomW, 0.2, roomD),
      new THREE.MeshLambertMaterial({color:0x3a4045})
    );
    floor.receiveShadow = true;
    interior.add(floor);

    // Furniture
    const wood = new THREE.MeshLambertMaterial({color:0x8b6914});
    const table = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 2), wood);
    table.position.set(0, 1, 0);
    table.castShadow = true;
    interior.add(table);

    const couch = new THREE.Mesh(
      new THREE.BoxGeometry(3.5, 1, 1.5),
      new THREE.MeshLambertMaterial({color:0x654321})
    );
    couch.position.set(4, 0.5, -4);
    couch.castShadow = true;
    interior.add(couch);

    interior.position.set(1000 + x, 0, 1000 + z);
    scene.add(interior);

    door.userData = {type:'door', houseIndex:houses.length};
    houses.push({
      extGroup:[body, door],
      hp:500,
      maxHp:500,
      interiorGroup:interior,
      entryPos:new THREE.Vector3(interior.position.x, 0.1, interior.position.z + roomD/2 - 1),
      exitPos:new THREE.Vector3(x, 0.1, z + d/2 + 2),
      destroyed:false
    });
  }

  // Create city buildings
  for(let i = 0; i < 70; i++){
    const x = rand(-180, 180);
    const z = rand(-180, 180);
    
    // Avoid forest area
    if(x > FOREST_START_X - 30) continue;
    
    if(Math.abs(x) < 25 || Math.abs(z) < 25){ i--; continue; }
    const makeHouse = Math.random() < 0.35;
    makeBuilding(x, z, makeHouse);
  }

  // ========== WILDLIFE (Predators) ==========
  const wildlife = new THREE.Group();
  scene.add(wildlife);

  function makePredator(type='leopard'){
    const animal = new THREE.Group();
    
    const bodyColor = type === 'leopard' ? 0xd4a574 : 0xc4a464;
    
    // Body
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(2, 1, 1),
      new THREE.MeshLambertMaterial({color:bodyColor})
    );
    body.position.y = 0.8;
    body.castShadow = true;
    animal.add(body);
    
    // Head
    const head = new THREE.Mesh(
      new THREE.BoxGeometry(0.8, 0.7, 0.7),
      new THREE.MeshLambertMaterial({color:bodyColor})
    );
    head.position.set(1.2, 0.8, 0);
    head.castShadow = true;
    animal.add(head);
    
    // Legs
    const legMat = new THREE.MeshLambertMaterial({color:bodyColor});
    for(let pos of [[0.6, 0.4], [0.6, -0.4], [-0.6, 0.4], [-0.6, -0.4]]){
      const leg = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.8, 0.3), legMat);
      leg.position.set(pos[0], 0.3, pos[1]);
      leg.castShadow = true;
      animal.add(leg);
    }
    
    // Tail
    const tail = new THREE.Mesh(
      new THREE.BoxGeometry(0.2, 0.2, 1.5),
      legMat
    );
    tail.position.set(-1.2, 0.8, 0);
    tail.castShadow = true;
    animal.add(tail);
    
    animal.userData = {
      type:'predator',
      species:type,
      alive:true,
      hp:80,
      speed:7,
      huntingVehicle:null,
      attackCooldown:0,
      hw:1, hh:1, hd:0.5
    };
    
    return animal;
  }

  // Spawn predators in forest
  for(let i = 0; i < 12; i++){
    const predator = makePredator(Math.random() < 0.6 ? 'leopard' : 'lion');
    predator.position.set(
      rand(FOREST_START_X + 20, FOREST_END_X - 20),
      0,
      rand(FOREST_START_Z + 20, FOREST_END_Z - 20)
    );
    wildlife.add(predator);
  }

  // ========== VEHICLES (COOLER DESIGNS) ==========
  function makeCoolCar(color=0x33aa66, type='sports'){
    const car = new THREE.Group();
    
    let bodySize = type === 'sports' ? [3, 0.7, 1.6] : [2.8, 0.8, 1.8];
    
    // Sleek body
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(...bodySize),
      new THREE.MeshLambertMaterial({
        color,
        emissive:color,
        emissiveIntensity:0.2
      })
    );
    body.position.y = 0.5;
    body.castShadow = true;
    body.receiveShadow = true;
    
    // Cabin with tinted windows
    const cabin = new THREE.Mesh(
      new THREE.BoxGeometry(1.6, 0.7, 1.4),
      new THREE.MeshLambertMaterial({
        color:0x1a1f24,
        transparent:true,
        opacity:0.7
      })
    );
    cabin.position.set(0, 1, 0);
    cabin.castShadow = true;
    
    // Sporty wheels
    const wheelMat = new THREE.MeshLambertMaterial({color:0x0a0a0a});
    function wheel(x, z){
      const w = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 0.4, 12), wheelMat);
      w.rotation.z = Math.PI/2;
      w.position.set(x, 0.35, z);
      w.castShadow = true;
      return w;
    }
    
    const wheelOffset = type === 'sports' ? 1.1 : 0.9;
    const wheelSpread = 0.8;
    
    car.add(body, cabin,
      wheel(wheelOffset, wheelSpread), wheel(-wheelOffset, wheelSpread),
      wheel(wheelOffset, -wheelSpread), wheel(-wheelOffset, -wheelSpread)
    );
    
    car.userData = {
      type:'car',
      speed:0,
      yaw:0,
      hp:type === 'sports' ? 120 : 100,
      maxHp:type === 'sports' ? 120 : 100,
      hw:bodySize[0]/2,
      hh:bodySize[1]/2,
      hd:bodySize[2]/2,
      driver:null,
      carType:type,
      lastStopPos:null
    };
    return car;
  }

  const cars = new THREE.Group();
  scene.add(cars);
  const carColors = [0xff4444, 0x4444ff, 0x44ff44, 0xffff44, 0xff44ff, 0x44ffff];

  for(let i = 0; i < 15; i++){
    const carType = Math.random() < 0.7 ? 'sports' : 'suv';
    const car = makeCoolCar(carColors[i % carColors.length], carType);
    
    let placed = false;
    let attempts = 0;
    while(!placed && attempts < 50){
      const x = rand(-150, 150);
      const z = rand(-150, 150);
      
      if(x > FOREST_START_X - 40) continue;
      
      if(Math.abs(x % 35) < 10 || Math.abs(z % 35) < 10){
        car.position.set(x, 0, z);
        
        let tooClose = false;
        for(let building of allBuildings){
          if(dist2(car.position, building.position) < 100){
            tooClose = true;
            break;
          }
        }
        
        if(!tooClose && dist2(car.position, player.position) > 300){
          cars.add(car);
          placed = true;
        }
      }
      attempts++;
    }
  }

  // ========== AI SOLDIERS ==========
  const aiArmy = new THREE.Group();
  scene.add(aiArmy);

  function spawnAI(n=25){
    for(let i = 0; i < n; i++){
      const colors = {
        shirt:new THREE.Color().setHSL(rand(0,1), 0.6, 0.4),
        pants:new THREE.Color().setHSL(rand(0.1,0.2), 0.4, 0.3),
        sleeve:new THREE.Color().setHSL(rand(0,1), 0.6, 0.4),
        hair:new THREE.Color().setHSL(rand(0,1), 0.5, 0.2)
      };
      
      const ai = makeRealisticHumanoid(colors);
      
      let placed = false;
      let attempts = 0;
      while(!placed && attempts < 50){
        const x = rand(-180, 180);
        const z = rand(-180, 180);
        
        if(x > FOREST_START_X - 40) continue;
        
        if(Math.abs(x % 35) < 10 || Math.abs(z % 35) < 10){
          attempts++;
          continue;
        }
        
        ai.position.set(x, 0, z);
        
        let tooClose = false;
        for(let building of allBuildings){
          if(dist2(ai.position, building.position) < 120){
            tooClose = true;
            break;
          }
        }
        
        if(!tooClose && dist2(ai.position, player.position) > 400){
          aiArmy.add(ai);
          placed = true;
        }
        attempts++;
      }
      
      if(!placed) continue;
      
      ai.userData.alive = true;
      ai.userData.hp = rand(50, 90);
      ai.userData.timer = rand(80, 200);
      ai.userData.speed = rand(2.5, 3.5);
      ai.userData.team = Math.random() < 0.5 ? 'red' : 'blue';
      ai.userData.lastShot = 0;
      ai.userData.weaponAnchor.add(makeAssaultRifle());
    }
  }
  spawnAI();

  // ========== PROJECTILES ==========
  const BULLETS = [], ROCKETS = [], EXPLOSIONS = [];

  function spawnBullet(pos, dir, speed, dmg, from='player'){
    const s = new THREE.Mesh(
      new THREE.SphereGeometry(0.08, 8, 8),
      new THREE.MeshBasicMaterial({
        color:from === 'player' ? 0xffdd00 : 0xffaaaa,
        emissive:from === 'player' ? 0x221100 : 0x110000,
        emissiveIntensity:0.7
      })
    );
    s.position.copy(pos);
    s.userData = {type:'bullet', vel:dir.clone().multiplyScalar(speed), life:2.5, from, dmg};
    scene.add(s);
    BULLETS.push(s);
    if(from === 'player') playRifleSound();
  }

  function spawnRocket(pos, dir, speed, dmg=200, radius=5, from='player'){
    const s = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.14, 0.6, 8),
      new THREE.MeshLambertMaterial({
        color:from === 'player' ? 0xff4422 : 0xff8833,
        emissive:0x441100,
        emissiveIntensity:0.7
      })
    );
    s.position.copy(pos);
    s.lookAt(pos.clone().add(dir));
    s.userData = {type:'rocket', vel:dir.clone().multiplyScalar(speed), life:6.0, from, radius, dmg};
    scene.add(s);
    ROCKETS.push(s);
    if(from === 'player') playRocketSound();
  }

  function explode(point, radius, src, damage=80){
    playExplosionSound();
    
    const fx = new THREE.Mesh(
      new THREE.SphereGeometry(radius * 0.9, 16, 12),
      new THREE.MeshBasicMaterial({color:0xff6633, transparent:true, opacity:0.7})
    );
    fx.position.copy(point);
    fx.userData = {type:'explosion', life:0.6};
    scene.add(fx);
    EXPLOSIONS.push(fx);
    
    // Damage targets
    const damageTargets = [
      ...aiArmy.children.filter(ai => ai.userData.alive),
      ...wildlife.children.filter(w => w.userData.alive),
      ...cars.children.filter(c => c.visible)
    ];
    
    damageTargets.forEach(target => {
      const distance = target.position.distanceTo(point);
      if(distance <= radius){
        const damageFactor = 1 - (distance / radius);
        const actualDamage = Math.floor(damage * damageFactor);
        
        if(target.userData.type === 'humanoid'){
          target.userData.hp -= actualDamage;
          if(target.userData.hp <= 0 && target.userData.alive){
            killTarget(target, src);
          }
        } else if(target.userData.type === 'car'){
          target.userData.hp = Math.max(0, target.userData.hp - actualDamage);
        } else if(target.userData.type === 'predator'){
          target.userData.hp -= actualDamage;
          if(target.userData.hp <= 0 && target.userData.alive){
            killPredator(target);
          }
        }
      }
    });
    
    // Player damage
    if(!onCar && player.position.distanceTo(point) <= radius){
      const distance = player.position.distanceTo(point);
      const damageFactor = 1 - (distance / radius);
      const playerDamage = Math.floor(50 * damageFactor);
      playerHP = Math.max(0, playerHP - playerDamage);
      updateBars();
      if(playerHP <= 0) showGameOver();
    }
  }

  // ========== KILL SYSTEM ==========
  function killTarget(target, killer){
    target.userData.alive = false;
    target.visible = false;
    totalKills++;
    
    let timeGain = Math.floor(target.userData.timer || 0);
    const teamColor = target.userData.team === 'red' ? 'Red' : 'Blue';
    
    if(killer === 'player'){
      playerTimer = Math.min(playerTimer + timeGain, 600);
      addKillMessage(`${teamColor} AI killed! +${timeGain}s`);
    }
  }

  function killPredator(predator){
    predator.userData.alive = false;
    predator.visible = false;
    totalKills++;
    
    playerTimer = Math.min(playerTimer + 20, 600);
    addKillMessage(`${predator.userData.species} killed! +20s`);
  }

  function addKillMessage(text, isWarning=false){
    const killMsg = document.createElement('div');
    killMsg.className = isWarning ? 'kill-msg wildlife-warning' : 'kill-msg';
    killMsg.textContent = text;
    document.getElementById('killFeed').appendChild(killMsg);
    
    setTimeout(() => {
      if(killMsg.parentNode) killMsg.parentNode.removeChild(killMsg);
    }, 3500);
  }

  // ========== FIRE SYSTEM ==========
  function fire(){
    const muzzlePos = player.userData.weaponAnchor.getWorldPosition(new THREE.Vector3());
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    
    if(weapon === 'rifle'){
      spawnBullet(muzzlePos, forward, onCar ? 45 : 55, 25, 'player');
    } else {
      if(rocketCooldown > 0) return;
      spawnRocket(muzzlePos, forward, 28, 200, 6, 'player');
      rocketCooldown = 3.5;
    }
  }

  // ========== WILDLIFE AI (Vehicle Hunters) ==========
  function wildlifeThink(dt){
    wildlife.children.forEach((predator, index) => {
      if(!predator.userData.alive) return;
      
      predator.userData.attackCooldown = Math.max(0, predator.userData.attackCooldown - dt);
      
      // Check if inside forest territory
      const inTerritory = predator.position.x > FOREST_START_X &&
                         predator.position.x < FOREST_END_X &&
                         predator.position.z > FOREST_START_Z &&
                         predator.position.z < FOREST_END_Z;
      
      // Find vehicles in territory
      let target = null;
      let tDist = 1e9;
      
      cars.children.forEach(car => {
        if(!car.visible || !car.userData.driver) return;
        
        const carInTerritory = car.position.x > FOREST_START_X - 20 &&
                              car.position.x < FOREST_END_X + 20 &&
                              car.position.z > FOREST_START_Z - 20 &&
                              car.position.z < FOREST_END_Z + 20;
        
        if(carInTerritory){
          const d = predator.position.distanceTo(car.position);
          if(d < tDist && d < 50){
            tDist = d;
            target = car;
          }
        }
      });
      
      if(target){
        // Hunt the vehicle
        const dx = target.position.x - predator.position.x;
        const dz = target.position.z - predator.position.z;
        predator.rotation.y = Math.atan2(dx, dz);
        
        const speed = predator.userData.speed * dt;
        predator.position.x += Math.sin(predator.rotation.y) * speed;
        predator.position.z += Math.cos(predator.rotation.y) * speed;
        
        // Attack vehicle
        if(tDist < 2.5 && predator.userData.attackCooldown === 0){
          target.userData.hp = Math.max(0, target.userData.hp - rand(15, 25));
          predator.userData.attackCooldown = 1.5;
          playAnimalRoar();
          
          if(target.userData.driver === 'player'){
            addKillMessage(`${predator.userData.species} attacks vehicle!`, true);
          }
        }
      } else if(inTerritory){
        // Patrol territory
        const patrolSpeed = predator.userData.speed * 0.3 * dt;
        predator.position.x += Math.sin(performance.now() * 0.0003 + index) * patrolSpeed;
        predator.position.z += Math.cos(performance.now() * 0.0003 + index) * patrolSpeed;
        
        // Stay in bounds
        predator.position.x = clamp(predator.position.x, FOREST_START_X + 10, FOREST_END_X - 10);
        predator.position.z = clamp(predator.position.z, FOREST_START_Z + 10, FOREST_END_Z - 10);
      }
    });
  }

  // ========== AI THINK ==========
  function aiThink(dt){
    aiArmy.children.forEach((ai, index) => {
      if(!ai.userData.alive) return;
      
      ai.userData.timer -= dt;
      if(ai.userData.timer <= 0){
        killTarget(ai, 'timer');
        return;
      }
      
      // Find targets
      let target = null;
      let tDist = 1e9;
      
      aiArmy.children.forEach(other => {
        if(other === ai || !other.userData.alive || other.userData.team === ai.userData.team) return;
        const d = ai.position.distanceTo(other.position);
        if(d < tDist && d < 35){
          tDist = d;
          target = other;
        }
      });
      
      const pDist = ai.position.distanceTo(player.position);
      if(Math.random() < 0.015 && pDist < 45){
        target = player;
        tDist = pDist;
      }
      
      if(target){
        const dx = target.position.x - ai.position.x;
        const dz = target.position.z - ai.position.z;
        ai.rotation.y = Math.atan2(dx, dz);
        
        if(tDist > 6){
          const speed = ai.userData.speed * dt;
          ai.position.x += Math.sin(ai.rotation.y) * speed;
          ai.position.z += Math.cos(ai.rotation.y) * speed;
        }
        
        // Shoot
        const now = performance.now();
        if(now - ai.userData.lastShot > 2500 && tDist < 35 && Math.random() < 0.02){
          ai.userData.lastShot = now;
          const muzzle = ai.userData.weaponAnchor.getWorldPosition(new THREE.Vector3());
          const shootDir = new THREE.Vector3(Math.sin(ai.rotation.y), 0, Math.cos(ai.rotation.y));
          spawnBullet(muzzle, shootDir, 38, 18, 'ai');
        }
      } else {
        // Patrol
        ai.userData.walkT = (ai.userData.walkT || 0) + dt * 0.5;
        const patrolSpeed = ai.userData.speed * 0.35 * dt;
        ai.position.x += Math.sin(ai.userData.walkT + index) * patrolSpeed;
        ai.position.z += Math.cos(ai.userData.walkT + index) * patrolSpeed;
      }
      
      // Walking animation (only when moving)
      const moving = target || Math.abs((ai.userData.walkT || 0) % 1) > 0.01;
      if(moving){
        const t = performance.now() * 0.001 * 2.5;
        const amp = target ? 0.7 : 0.25;
        
        ai.userData.legL.rotation.x = Math.sin(t + index) * amp;
        ai.userData.legR.rotation.x = Math.sin(t + index + Math.PI) * amp;
        ai.userData.armL.rotation.x = Math.sin(t + index + Math.PI) * amp * 0.5;
        ai.userData.armR.rotation.x = Math.sin(t + index) * amp * 0.5;
      } else {
        // Reset to standing position
        ai.userData.legL.rotation.x = 0;
        ai.userData.legR.rotation.x = 0;
        ai.userData.armL.rotation.x = 0;
        ai.userData.armR.rotation.x = 0;
      }
    });
  }

  // ========== VEHICLE PHYSICS ==========
  function carPhysics(dt){
    cars.children.forEach(car => {
      if(car.userData.driver === 'player'){
        const accel = (keys['ArrowUp'] || keys['KeyW'] ? 1 : 0) +
                     (keys['ArrowDown'] || keys['KeyS'] ? -0.6 : 0);
        car.userData.speed += accel * 30 * dt;
        car.userData.speed = clamp(car.userData.speed, -10,
          car.userData.carType === 'sports' ? 20 : 16);
        
        if(keys['ArrowLeft'] || keys['KeyA'])
          car.userData.yaw += 2 * dt * Math.sign(car.userData.speed || 1);
        if(keys['ArrowRight'] || keys['KeyD'])
          car.userData.yaw -= 2 * dt * Math.sign(car.userData.speed || 1);
        
        // Store last position when moving
        if(Math.abs(car.userData.speed) > 0.1){
          car.userData.lastStopPos = car.position.clone();
        }
      } else {
        car.userData.speed = lerp(car.userData.speed, 0, 0.06);
      }
      
      // Movement
      car.rotation.y = car.userData.yaw;
      const vx = Math.sin(car.userData.yaw) * car.userData.speed * dt;
      const vz = Math.cos(car.userData.yaw) * car.userData.speed * dt;
      car.position.x += vx;
      car.position.z += vz;
      
      // Collision damage with AI and predators
      const speedSq = car.userData.speed * car.userData.speed;
      if(speedSq > 12){
        [...aiArmy.children, ...wildlife.children].forEach(target => {
          if(!target.userData.alive) return;
          if(target.position.distanceTo(car.position) < 2.5){
            if(target.userData.type === 'humanoid'){
              killTarget(target, 'vehicle');
              addKillMessage('AI roadkill!');
            } else if(target.userData.type === 'predator'){
              killPredator(target);
            }
          }
        });
      }
      
      // Vehicle destruction
      if(car.userData.hp <= 0 && car.visible){
        explode(car.position.clone(), 5, 'vehicle');
        car.visible = false;
        
        if(car.userData.driver === 'player'){
          playerHP = Math.max(0, Math.floor(playerHP * 0.5));
          updateBars();
          if(playerHP <= 0) showGameOver();
          onCar = false;
          
          // Use last stop position for exit
          if(car.userData.lastStopPos){
            player.position.copy(car.userData.lastStopPos);
            player.position.x += 3;
          } else {
            player.position.copy(car.position);
            player.position.x += 3;
          }
          
          currentCar = null;
          player.visible = true;
          document.getElementById('modeTxt').textContent = 'On Foot';
          addKillMessage('Vehicle destroyed!');
        }
      }
    });
  }

  // ========== PROJECTILE UPDATES ==========
  function bulletsUpdate(dt){
    for(let i = BULLETS.length - 1; i >= 0; i--){
      const b = BULLETS[i];
      b.userData.life -= dt;
      b.position.addScaledVector(b.userData.vel, dt);
      
      if(b.userData.life <= 0 || b.position.y <= 0.1){
        scene.remove(b);
        BULLETS.splice(i, 1);
        continue;
      }
      
      let hitTarget = false;
      
      for(const ai of aiArmy.children){
        if(!ai.userData.alive || hitTarget) continue;
        if(ai.position.distanceTo(b.position) < 0.7){
          ai.userData.hp -= b.userData.dmg;
          if(ai.userData.hp <= 0) killTarget(ai, b.userData.from);
          hitTarget = true;
          break;
        }
      }
      
      if(!hitTarget){
        for(const predator of wildlife.children){
          if(!predator.userData.alive || hitTarget) continue;
          if(predator.position.distanceTo(b.position) < 0.8){
            predator.userData.hp -= b.userData.dmg;
            if(predator.userData.hp <= 0) killPredator(predator);
            hitTarget = true;
            break;
          }
        }
      }
      
      if(!hitTarget && b.userData.from === 'ai'){
        if(onCar && currentCar && currentCar.visible){
          if(currentCar.position.distanceTo(b.position) < 2){
            currentCar.userData.hp -= b.userData.dmg * 2;
            hitTarget = true;
          }
        } else if(!onCar && player.position.distanceTo(b.position) < 0.8){
          playerHP = Math.max(0, playerHP - b.userData.dmg);
          updateBars();
          if(playerHP <= 0) showGameOver();
          hitTarget = true;
        }
      }
      
      if(hitTarget){
        scene.remove(b);
        BULLETS.splice(i, 1);
      }
    }
  }

  function rocketsUpdate(dt){
    for(let i = ROCKETS.length - 1; i >= 0; i--){
      const r = ROCKETS[i];
      r.userData.life -= dt;
      r.position.addScaledVector(r.userData.vel, dt);
      
      if(r.userData.life <= 0){
        scene.remove(r);
        ROCKETS.splice(i, 1);
        continue;
      }
      
      let hit = false;
      
      if(r.position.y <= 0.2){
        hit = true;
        r.position.y = 0.2;
      }
      
      if(!hit){
        const targets = [
          ...cars.children.filter(c => c.visible),
          ...aiArmy.children.filter(ai => ai.userData.alive),
          ...wildlife.children.filter(w => w.userData.alive)
        ];
        
        for(const target of targets){
          const hitRadius = target.userData.type === 'car' ? 2 : 1.2;
          if(target.position.distanceTo(r.position) < hitRadius){
            hit = true;
            break;
          }
        }
      }
      
      if(hit){
        explode(r.position.clone(), r.userData.radius, r.userData.from, r.userData.dmg);
        scene.remove(r);
        ROCKETS.splice(i, 1);
      }
    }
  }

  function explosionsUpdate(dt){
    for(let i = EXPLOSIONS.length - 1; i >= 0; i--){
      const fx = EXPLOSIONS[i];
      fx.userData.life -= dt;
      fx.scale.multiplyScalar(1 + 3 * dt);
      fx.material.opacity = (fx.userData.life / 0.6) * 0.7;
      
      if(fx.userData.life <= 0){
        scene.remove(fx);
        EXPLOSIONS.splice(i, 1);
      }
    }
  }

  // ========== CONTEXT ACTIONS ==========
  function contextAction(){
    const actionRange = 4;
    
    if(!inHouse && !onCar){
      // House entry (night only)
      if(isNight){
        let nearest = -1, best = actionRange * actionRange;
        houses.forEach((h, i) => {
          if(h.destroyed) return;
          const doorMesh = h.extGroup[1];
          const d2 = dist2(player.position, doorMesh.position);
          if(d2 < best){
            best = d2;
            nearest = i;
          }
        });
        
        if(nearest >= 0){
          enterHouse(nearest);
          return;
        }
      }
      
      // Vehicle entry
      const nearCar = cars.children.find(c =>
        c.visible && c.position.distanceTo(player.position) < 4
      );
      if(nearCar){
        toggleCar(nearCar);
        return;
      }
    }
    
    if(inHouse){
      const H = houses[currentHouseIndex];
      if(player.position.distanceTo(H.entryPos) < actionRange){
        exitHouse();
        return;
      }
    }
    
    if(onCar) toggleCar(currentCar);
  }

  function enterHouse(index){
    const H = houses[index];
    if(H.destroyed) return;
    
    inHouse = true;
    currentHouseIndex = index;
    player.position.copy(H.entryPos);
    player.rotation.y = Math.PI;
    document.getElementById('modeTxt').textContent = 'Inside Building';
    updateBars();
    addKillMessage('Entered building');
  }

  function exitHouse(){
    const H = houses[currentHouseIndex];
    inHouse = false;
    currentHouseIndex = -1;
    player.position.copy(H.exitPos);
    document.getElementById('modeTxt').textContent = 'On Foot';
    updateBars();
    addKillMessage('Left building');
  }

  function toggleCar(c){
    if(!c) return;
    
    if(onCar){
      onCar = false;
      if(currentCar){
        currentCar.userData.driver = null;
        
        // Use last stop position for proper exit
        if(currentCar.userData.lastStopPos){
          player.position.copy(currentCar.userData.lastStopPos);
          player.position.x += 3;
        } else {
          player.position.copy(currentCar.position);
          player.position.x += 3;
        }
        
        currentCar = null;
      }
      player.visible = true;
      document.getElementById('modeTxt').textContent = 'On Foot';
      addKillMessage('Exited vehicle');
      checkLocation();
      return;
    }
    
    if(c.userData.driver || !c.visible) return;
    
    onCar = true;
    currentCar = c;
    c.userData.driver = 'player';
    c.userData.lastStopPos = c.position.clone();
    player.visible = false;
    document.getElementById('modeTxt').textContent = 'In ' + (c.userData.carType === 'sports' ? 'Sports Car' : 'SUV');
    addKillMessage('Entered ' + c.userData.carType);
    checkLocation();
  }

  // ========== LOCATION DETECTION ==========
  function checkLocation(){
    const pos = onCar ? currentCar.position : player.position;
    
    let newLocation = 'Kigali City';
    
    // Check if in forest
    if(pos.x > FOREST_START_X && pos.x < FOREST_END_X &&
       pos.z > FOREST_START_Z && pos.z < FOREST_END_Z){
      newLocation = 'Nyungwe Forest';
    }
    
    // Check landmarks
    landmarks.children.forEach(landmark => {
      const dist = pos.distanceTo(landmark.position);
      if(dist < 50){
        newLocation = landmark.userData.name;
      }
    });
    
    if(newLocation !== currentLocation){
      currentLocation = newLocation;
      showLocationInfo(newLocation);
    }
    
    document.getElementById('locationTxt').textContent = currentLocation;
  }

  function showLocationInfo(location){
    const el = document.getElementById('locationInfo');
    el.textContent = location;
    el.style.display = 'block';
    
    setTimeout(() => {
      el.style.display = 'none';
    }, 2000);
  }

  // ========== DAY/NIGHT SYSTEM ==========
  function updateDayNightCycle(dt){
    dayNightTimer += dt;
    const cycleDuration = isNight ? NIGHT_DURATION : DAY_DURATION;
    
    if(dayNightTimer >= cycleDuration){
      dayNightTimer = 0;
      isNight = !isNight;
      applyLighting();
      addKillMessage(isNight ? 'Night falls...' : 'Dawn breaks!');
    }
  }

  function applyLighting(){
    const dayColor = new THREE.Color(0x87ceeb);
    const nightColor = new THREE.Color(0x0f1419);
    
    scene.background = isNight ? nightColor : dayColor;
    scene.fog.color.setHex(isNight ? 0x1a1f24 : 0x87ceeb);
    
    sun.intensity = isNight ? 0.15 : 1.3;
    moon.intensity = isNight ? 0.6 : 0.0;
    ambient.intensity = isNight ? 0.35 : 0.5;
    
    const timeIcon = document.getElementById('timeIcon');
    const dayNightTxt = document.getElementById('dayNightTxt');
    
    if(isNight){
      timeIcon.className = 'time-icon night-icon';
      dayNightTxt.textContent = 'Night';
    } else {
      timeIcon.className = 'time-icon day-icon';
      dayNightTxt.textContent = 'Day';
    }
  }

  function toggleNight(){
    isNight = !isNight;
    applyLighting();
    addKillMessage('Day/night toggled!');
  }

  applyLighting();

  // ========== INPUT SYSTEM ==========
  const keys = {};
  document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if(e.code === 'KeyH') setWeapon(weapon === 'rifle' ? 'launcher' : 'rifle');
    if(e.code === 'KeyE') contextAction();
    if(e.code === 'Digit5'){
      const el = document.getElementById('controls');
      el.style.display = (el.style.display === 'none' || !el.style.display) ? 'block' : 'none';
    }
    if(e.code === 'KeyN') toggleNight();
    if(e.code === 'KeyM'){
      audioEnabled = !audioEnabled;
      document.getElementById('audioToggle').textContent = audioEnabled ? 'Audio: ON' : 'Audio: OFF';
    }
  });
  document.addEventListener('keyup', (e) => { keys[e.code] = false; });

  // Mouse controls
  let yaw = 0, pitch = 0;
  let isPointerLocked = false;

  document.addEventListener('click', (e) => {
    if(document.pointerLockElement !== canvas){
      canvas.requestPointerLock();
    } else {
      fire();
    }
  });

  document.addEventListener('pointerlockchange', () => {
    isPointerLocked = document.pointerLockElement === canvas;
  });

  document.addEventListener('mousemove', (e) => {
    if(isPointerLocked){
      yaw -= e.movementX * 0.003;
      pitch -= e.movementY * 0.003;
      pitch = clamp(pitch, -Math.PI/2.5, Math.PI/2.5);
    }
  });

  // ========== PLAYER MOVEMENT ==========
  let yVel = 0;
  let isJumping = false;

  function playerMovement(dt){
    if(onCar){
      const carPos = currentCar.position.clone();
      const cameraOffset = new THREE.Vector3(
        -Math.sin(currentCar.userData.yaw) * 7,
        5,
        -Math.cos(currentCar.userData.yaw) * 7
      );
      camera.position.lerp(carPos.add(cameraOffset), 0.15);
      camera.lookAt(currentCar.position.clone().add(new THREE.Vector3(0, 1, 0)));
      checkLocation();
      return;
    }

    // On foot movement
    let mx = 0, mz = 0;
    if(keys['KeyW']) mz -= 1;
    if(keys['KeyS']) mz += 1;
    if(keys['KeyA']) mx -= 1;
    if(keys['KeyD']) mx += 1;

    const mag = Math.hypot(mx, mz) || 1;
    mx /= mag; mz /= mag;

    const speed = 6;
    player.position.x += mx * speed * dt;
    player.position.z += mz * speed * dt;

    // Jumping
    if(keys['Space'] && player.position.y <= 0.01 && !isJumping){
      yVel = 7;
      isJumping = true;
    }

    yVel -= 14 * dt;
    player.position.y = Math.max(0, player.position.y + yVel * dt);

    if(player.position.y === 0){
      yVel = 0;
      isJumping = false;
    }

    // Third-person camera
    const behind = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).multiplyScalar(7);
    const cameraTarget = new THREE.Vector3(
      player.position.x - behind.x,
      player.position.y + 5 - pitch * 2,
      player.position.z - behind.z
    );

    camera.position.lerp(cameraTarget, 0.18);
    camera.lookAt(player.position.clone().add(new THREE.Vector3(0, 2, 0)));

    // Walking animation (only when moving)
    const moving = (Math.abs(mx) + Math.abs(mz)) > 0.01;
    if(moving){
      const t = performance.now() * 0.001 * 3;
      const amp = 0.7;

      player.userData.legL.rotation.x = Math.sin(t) * amp;
      player.userData.legR.rotation.x = Math.sin(t + Math.PI) * amp;
      player.userData.armL.rotation.x = Math.sin(t + Math.PI) * amp * 0.5;
      player.userData.armR.rotation.x = Math.sin(t) * amp * 0.5;
    } else {
      // Reset to standing position
      player.userData.legL.rotation.x = 0;
      player.userData.legR.rotation.x = 0;
      player.userData.armL.rotation.x = 0;
      player.userData.armR.rotation.x = 0;
    }

    checkLocation();
  }

  // ========== UI UPDATES ==========
  function updateBars(){
    const hpPercent = clamp(playerHP / 100 * 100, 0, 100);
    document.getElementById('hpbar').style.width = hpPercent + '%';
    document.getElementById('hpTxt').textContent = Math.round(hpPercent) + '%';

    const hpBar = document.querySelector('#hpbar').parentElement;
    hpBar.className = hpPercent > 60 ? 'bar ok' : hpPercent > 30 ? 'bar warn' : 'bar bad';

    const m = Math.floor(playerTimer / 60);
    const s = Math.floor(playerTimer % 60);
    document.getElementById('timerDisplay').textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;

    document.getElementById('killsTxt').textContent = totalKills;
  }

  function showGameOver(){
    const finalTime = Date.now() - gameStartTime;
    const minutes = Math.floor(finalTime / 60000);
    const seconds = Math.floor((finalTime % 60000) / 1000);

    document.getElementById('finalTime').textContent = `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
    document.getElementById('finalKills').textContent = totalKills;
    document.getElementById('gameover').style.display = 'flex';
  }

  document.getElementById('btnNew').addEventListener('click', () => location.reload());

  function tickTimer(dt){
    if(playerHP <= 0) return;

    playerTimer -= dt;
    if(playerTimer <= 0){
      playerTimer = 0;
      showGameOver();
    }
  }

  // ========== MINIMAP ==========
  const minimapCanvas = document.getElementById('minimap');
  const mctx = minimapCanvas.getContext('2d');

  function drawMinimap(){
    mctx.clearRect(0, 0, 200, 200);

    const scale = 0.25;
    const cx = 100, cy = 100;

    function drawCircle(x, z, r, color){
      mctx.fillStyle = color;
      mctx.beginPath();
      mctx.arc(cx + x * scale, cy + z * scale, r, 0, Math.PI * 2);
      mctx.fill();
    }

    function drawRect(x, z, w, h, color){
      mctx.fillStyle = color;
      mctx.fillRect(cx + x * scale - w/2, cy + z * scale - h/2, w, h);
    }

    // Forest area
    mctx.fillStyle = 'rgba(26, 90, 26, 0.3)';
    mctx.fillRect(
      cx + FOREST_START_X * scale,
      cy + FOREST_START_Z * scale,
      (FOREST_END_X - FOREST_START_X) * scale,
      (FOREST_END_Z - FOREST_START_Z) * scale
    );

    // Roads
    mctx.strokeStyle = '#333';
    mctx.lineWidth = 1;
    for(let i = -10; i <= 10; i++){
      mctx.beginPath();
      mctx.moveTo(0, cy + i * 35 * scale);
      mctx.lineTo(200, cy + i * 35 * scale);
      mctx.stroke();
    }

    // Buildings
    allBuildings.forEach(building => {
      if(building.visible){
        drawRect(building.position.x, building.position.z, 2, 2, '#666');
      }
    });

    // Landmarks
    landmarks.children.forEach(landmark => {
      drawCircle(landmark.position.x, landmark.position.z, 4, '#ffd700');
    });

    // Player
    drawCircle(player.position.x, player.position.z, 6, '#00aaff');

    // Vehicles
    cars.children.forEach(c => {
      if(c.visible){
        const color = c.userData.driver === 'player' ? '#00ff00' : '#22aa44';
        drawRect(c.position.x, c.position.z, 4, 3, color);
      }
    });

    // AI
    aiArmy.children.forEach(ai => {
      if(ai.userData.alive){
        const color = ai.userData.team === 'red' ? '#ff4444' : '#4444ff';
        drawCircle(ai.position.x, ai.position.z, 2, color);
      }
    });

    // Wildlife
    wildlife.children.forEach(predator => {
      if(predator.userData.alive){
        drawCircle(predator.position.x, predator.position.z, 2, '#ff8800');
      }
    });
  }

  // ========== MAIN GAME LOOP ==========
  let lastTime = performance.now();

  function gameLoop(currentTime){
    const dt = Math.min(0.033, (currentTime - lastTime) / 1000);
    lastTime = currentTime;

    if(rocketCooldown > 0) rocketCooldown = Math.max(0, rocketCooldown - dt);

    updateDayNightCycle(dt);
    playerMovement(dt);
    carPhysics(dt);
    aiThink(dt);
    wildlifeThink(dt);

    bulletsUpdate(dt);
    rocketsUpdate(dt);
    explosionsUpdate(dt);

    tickTimer(dt);
    updateBars();
    drawMinimap();

    renderer.render(scene, camera);
    requestAnimationFrame(gameLoop);
  }

  requestAnimationFrame(gameLoop);

  console.log('BRU GTA: Kigali Forest & Wildlife Edition Loaded!');
  console.log('Total Lines: 2500+');
  console.log('Features: Realistic humanoids, walking animations, Nyungwe Forest, Rwandan landmarks, wildlife hunters');
  console.log('Creator: INEZA AIME BRUNO');
})();
</script>
</body>
</html>